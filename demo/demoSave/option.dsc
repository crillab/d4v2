("help,h", "Help screen")
("input,i", boost::program_options::value<std::string>(), "(required) Path to get the input file")
("input-type,it", boost::program_options::value<std::string>()->default_value("cnf"), "The input type")
("method,m", boost::program_options::value<std::string>(), "(required) The method we run (counting for model counting, ddnnf-compiler for decision DNNF compilation, projMC for a dedicated projected model counting, max#SAT for running a max#sat solver, erosion for running the erosion process).")
("erosion-option-depth",boost::program_options::value<int>()->default_value(-1),"Give the maximum number of iteration for the erosion process.")
("solver,s", boost::program_options::value<std::string>()->default_value("minisat"), "The solver we will use")
("preproc-solver,ps", boost::program_options::value<std::string>()->default_value("minisat"), "The solver we will use in the preproc")
("preproc,p",boost::program_options::value<std::string>()->default_value("basic"), "The preprocessing technique we will use (basic, backbone, vivification, occElimination, combinaison).")
("preproc-reducer-iteration",boost::program_options::value<int>()->default_value(10), "The number of iterations for the preproc that call reducer (-1 means we want to apply until we reach a fix point).")
("preproc-timeout",boost::program_options::value<int>()->default_value(0), "The time in second given to the preproc (0 means no timeout).")
("scoring-method,sm",boost::program_options::value<std::string>()->default_value("vsads"),"The scoring method used for selecting the next variable. [mom, dlcs, vsids, vsads, jwts]")
("scoring-method-freq-decay",boost::program_options::value<unsigned>()->default_value(128),"Gives the decay frequency")
("occurrence-manager,om",boost::program_options::value<std::string>()->default_value("dynamic"),"The occurrence manager used. [add a description]")
("phase-heuristic,ph",boost::program_options::value<std::string>()->default_value("polarity"),"The way the phase of the next decision is selected (false, true, polarity or occurrence).")
("phase-heuristic-reversed,pha", boost::program_options::value<bool>()->default_value(false), "Consider or not the reverse of the current phase.")
("partitioning-heuristic,pvh",boost::program_options::value<std::string>()->default_value("decomposition-static-dual"),"The method used to compute a cut. [none, decomposition-static, bipartition-primal or bipartition-dual]")
("partitioning-heuristic-partitioner,php",boost::program_options::value<std::string>()->default_value("patoh"),"The partitioner we will call (patoh or kahypar).")
("partitioning-heuristic-bipartite-phase",boost::program_options::value<std::string>()->default_value("none"),"Use a two phases heuristic, where the tree decomposition construction is given in parameter [none, natural, primal or dual].")
("partitioning-heuristic-bipartite-phase-dynamic",boost::program_options::value<double>()->default_value(0),"Use a static decomposition when it seems that the initial decomposition is no more good enough (the given value gives the balanced limit ratio).")
("partitioning-heuristic-bipartite-phase-static",boost::program_options::value<int>()->default_value(0),"Use a static decomposition when the number of variable is more than the given parameter. Switch to the dynamic decomposition otherwise. If 0, this option is deactivated.")
("partitioning-heuristic-simplification-equivalence,phse",boost::program_options::value<bool>()->default_value(true),"The graph with be simplified by considering literal equivalence.")
("partitioning-heuristic-simplification-hyperedge,phsh",boost::program_options::value<bool>()->default_value(true),"The graph with be simplified by reducing the hyper edges.")
("cache-reduction-strategy,crs", boost::program_options::value<std::string>()->default_value("none"), "The strategy used to reduce the cache structure [none, expectation, cache or sharpSAT].")
("cache-reduction-strategy-cachet-limit,crscl", boost::program_options::value<unsigned long>()->default_value(10UL * (1<<21)), "The limit in term of number of entries, the cachet reduction strategy allows.")
("cache-reduction-strategy-expectation-limit,crsel", boost::program_options::value<unsigned long>()->default_value(100000), "The frequency in term of number of negative hits used for the expectation reduction strategy allows.")
("cache-reduction-strategy-expectation-ratio,crser", boost::program_options::value<double>()->default_value(0.3), "The ratio used to decide if a clause can be kept or not.")
("cache-size-first-page", boost::program_options::value<unsigned long>()->default_value((1UL<<32)), "The block size of memory allocated for the first page of the cache structure.")
("cache-size-additional-page", boost::program_options::value<unsigned long>()->default_value((1UL<<29)), "The block size of memory allocated for the next page of the cache structure.")
("cache-store-strategy", boost::program_options::value<std::string>()->default_value("not-touched"), "The strategy used to store the clause in a bucket (all, not-binary and not-touched).")
("cache-clause-representation", boost::program_options::value<std::string>()->default_value("clause"), "The way the clause are represented in the cache (combi, sym, clause and index).")
("cache-clause-representation-combi-limitVar-sym", boost::program_options::value<unsigned>()->default_value(20), "In the mixed strategy, if we have less than a given number of variable then we use the symmetry caching representation.")
("cache-clause-representation-combi-limitVar-index", boost::program_options::value<unsigned>()->default_value(2000), "In the mixed strategy, if we have more than a given number of variable then we use the index caching representation.")
("cache-limit-number-variable", boost::program_options::value<unsigned>()->default_value(100000), "The number of variables threshold used to decide if the cache is used or not.")
("cache-limit-ratio", boost::program_options::value<double>()->default_value(0), "For the dynamic limit, posHit/negHit < ratio.")
("cache-activated", boost::program_options::value<bool>()->default_value(true), "Activate or not the cache.")
("cache-method", boost::program_options::value<std::string>()->default_value("list"), "The way the collision are handled (no-collision or list).")
("float-precision,fp", boost::program_options::value<int>()->default_value(128), "The precision for the float.")
("float,f", boost::program_options::value<bool>()->default_value(false), "If the count is computed as a float or not.")
("dump-ddnnf", boost::program_options::value<std::string>(), "Print out the decision DNNF formula in a given file.")
("query,q", boost::program_options::value<std::string>(), "Perform the queries given in a file (m l1 l2 ... ln 0 for a model counting query, and d l1 l2 ... ln 0 for a satisfiability query).")
("projMC-refinement", boost::program_options::value<bool>()->default_value(false), "Try to reduce the set of selector by computing a MSS.")
("keyword-output-format-solution", boost::program_options::value<std::string>()->default_value("s"), "The keyword prints in front of the solution when it is printed out.")
("output-format", boost::program_options::value<std::string>()->default_value("classic"), "The way the solution is printed out ('classic' only gives the number of solution after printing 's', 'competition' follows the MC competition 2021).")
("ere-greedy-init",boost::program_options::value<bool>()->default_value(false),"Search for a first interpretation greedily.")
("ere-and-dig",boost::program_options::value<bool>()->default_value(true),"When a decomposable AND node occurs we search for an instantiation to be able to get a bound.")
("ere-threshold",boost::program_options::value<double>()->default_value(1.0),"Search if we can find an assignment such that the number of weighted models is greater than a given threshold.")
("ere-exist-cut-upperBound",boost::program_options::value<bool>()->default_value(true),"Activate the cutting process on the max variables regarding an upper bound.")
("ere-exist-heuristic-phase-best",boost::program_options::value<bool>()->default_value(true),"Try to look if the best solution found so far is a good phase heuristic.")
("ere-exist-heuristic-phase-random",boost::program_options::value<unsigned>()->default_value(5),"That is the percentage of random choice for the phase selection on the exist variables.")
("ere-exist-cache-reduction-strategy", boost::program_options::value<std::string>()->default_value("none"), "The strategy used to reduce the cache structure [none, expectation, cache or sharpSAT].")
("ere-exist-cache-reduction-strategy-cachet-limit", boost::program_options::value<unsigned long>()->default_value(10UL * (1<<21)), "The limit in term of number of entries, the cachet reduction strategy allows.")
("ere-exist-cache-reduction-strategy-expectation-limit", boost::program_options::value<unsigned long>()->default_value(100000), "The frequency in term of number of negative hits used for the expectation reduction strategy allows.")
("ere-exist-cache-reduction-strategy-expectation-ratio", boost::program_options::value<double>()->default_value(0.3), "The ratio used to decide if a clause can be kept or not.")
("ere-exist-cache-size-first-page", boost::program_options::value<unsigned long>()->default_value((1UL<<32)), "The block size of memory allocated for the first page of the cache structure.")
("ere-exist-cache-size-additional-page", boost::program_options::value<unsigned long>()->default_value((1UL<<29)), "The block size of memory allocated for the next page of the cache structure.")
("ere-exist-cache-store-strategy", boost::program_options::value<std::string>()->default_value("not-touched"), "The strategy used to store the clause in a bucket (all, not-binary and not-touched).")
("ere-exist-cache-clause-representation", boost::program_options::value<std::string>()->default_value("clause"), "The way the clause are represented in the cache (combi, sym, clause and index).")
("ere-exist-cache-clause-representation-combi-limitVar-sym", boost::program_options::value<unsigned>()->default_value(20), "In the mixed strategy, if we have less than a given number of variable then we use the symmetry caching representation.")
("ere-exist-cache-clause-representation-combi-limitVar-index", boost::program_options::value<unsigned>()->default_value(2000), "In the mixed strategy, if we have more than a given number of variable then we use the index caching representation.")
("ere-exist-cache-limit-number-variable", boost::program_options::value<unsigned>()->default_value(100000), "The number of variables threshold used to decide if the cache is used or not.")
("ere-exist-cache-limit-ratio", boost::program_options::value<double>()->default_value(0), "For the dynamic limit, posHit/negHit < ratio.")
("ere-exist-cache-activated", boost::program_options::value<bool>()->default_value(true), "Activate or not the cache.")
("ere-exist-cache-method", boost::program_options::value<std::string>()->default_value("list"), "The way the collision are handled (no-collision or list).")
("ere-exist-scoring-method,sm",boost::program_options::value<std::string>()->default_value("vsads"),"The scoring method used for selecting the next variable. [mom, dlcs, vsids, vsads, jwts]")
("ere-exist-scoring-method-freq-decay",boost::program_options::value<unsigned>()->default_value(128),"Gives the decay frequency")
("ere-exist-phase-heuristic",boost::program_options::value<std::string>()->default_value("polarity"),"The way the phase of the next decision is selected (false, true, polarity or occurrence).")
("ere-exist-phase-heuristic-reversed", boost::program_options::value<bool>()->default_value(false), "Consider or not the reverse of the current phase.")
("ere-random-cache-reduction-strategy", boost::program_options::value<std::string>()->default_value("none"), "The strategy used to reduce the cache structure [none, expectation, cache or sharpSAT].")
("ere-random-cache-reduction-strategy-cachet-limit", boost::program_options::value<unsigned long>()->default_value(10UL * (1<<21)), "The limit in term of number of entries, the cachet reduction strategy allows.")
("ere-random-cache-reduction-strategy-expectation-limit", boost::program_options::value<unsigned long>()->default_value(100000), "The frequency in term of number of negative hits used for the expectation reduction strategy allows.")
("ere-random-cache-reduction-strategy-expectation-ratio", boost::program_options::value<double>()->default_value(0.3), "The ratio used to decide if a clause can be kept or not.")
("ere-random-cache-size-first-page", boost::program_options::value<unsigned long>()->default_value((1UL<<32)), "The block size of memory allocated for the first page of the cache structure.")
("ere-random-cache-size-additional-page", boost::program_options::value<unsigned long>()->default_value((1UL<<29)), "The block size of memory allocated for the next page of the cache structure.")
("ere-random-cache-store-strategy", boost::program_options::value<std::string>()->default_value("not-touched"), "The strategy used to store the clause in a bucket (all, not-binary and not-touched).")
("ere-random-cache-clause-representation", boost::program_options::value<std::string>()->default_value("clause"), "The way the clause are represented in the cache (combi, sym, clause and index).")
("ere-random-cache-clause-representation-combi-limitVar-sym", boost::program_options::value<unsigned>()->default_value(20), "In the mixed strategy, if we have less than a given number of variable then we use the symmetry caching representation.")
("ere-random-cache-clause-representation-combi-limitVar-index", boost::program_options::value<unsigned>()->default_value(2000), "In the mixed strategy, if we have more than a given number of variable then we use the index caching representation.")
("ere-random-cache-limit-number-variable", boost::program_options::value<unsigned>()->default_value(100000), "The number of variables threshold used to decide if the cache is used or not.")
("ere-random-cache-limit-ratio", boost::program_options::value<double>()->default_value(0), "For the dynamic limit, posHit/negHit < ratio.")
("ere-random-cache-activated", boost::program_options::value<bool>()->default_value(true), "Activate or not the cache.")
("ere-random-cache-method", boost::program_options::value<std::string>()->default_value("list"), "The way the collision are handled (no-collision or list).")
("ere-random-scoring-method,sm",boost::program_options::value<std::string>()->default_value("vsads"),"The scoring method used for selecting the next variable. [mom, dlcs, vsids, vsads, jwts]")
("ere-random-scoring-method-freq-decay",boost::program_options::value<unsigned>()->default_value(128),"Gives the decay frequency")
("ere-random-phase-heuristic",boost::program_options::value<std::string>()->default_value("polarity"),"The way the phase of the next decision is selected (false, true, polarity or occurrence).")
("ere-random-phase-heuristic-reversed", boost::program_options::value<bool>()->default_value(false), "Consider or not the reverse of the current phase.")
("ere-component-on-random",boost::program_options::value<bool>()->default_value(true),"Compute the connected component focusing or not the set of random variables.")
("max#sat-greedy-init",boost::program_options::value<bool>()->default_value(false),"Search for a first interpretation greedily.")
("max#sat-and-dig",boost::program_options::value<bool>()->default_value(true),"When a decomposable AND node occurs we search for an instantiation to be able to get a bound.")
("max#sat-threshold",boost::program_options::value<double>()->default_value(1.0),"Search if we can find an assignment such that the number of weighted models is greater than a given threshold.")
("max#sat-max-cut-upperBound",boost::program_options::value<bool>()->default_value(true),"Activate the cutting process on the max variables regarding an upper bound.")
("max#sat-max-heuristic-phase",boost::program_options::value<std::string>()->default_value("best"),"Try to look if the best solution found so far is a good phase heuristic (best) or if it worth to consider the literal with th higher weight.")
("max#sat-max-heuristic-phase-random",boost::program_options::value<unsigned>()->default_value(5),"That is the percentage of random choice for the phase selection on the max variables.")
("max#sat-max-cache-reduction-strategy", boost::program_options::value<std::string>()->default_value("none"), "The strategy used to reduce the cache structure [none, expectation, cache or sharpSAT].")
("max#sat-max-cache-reduction-strategy-cachet-limit", boost::program_options::value<unsigned long>()->default_value(10UL * (1<<21)), "The limit in term of number of entries, the cachet reduction strategy allows.")
("max#sat-max-cache-reduction-strategy-expectation-limit", boost::program_options::value<unsigned long>()->default_value(100000), "The frequency in term of number of negative hits used for the expectation reduction strategy allows.")
("max#sat-max-cache-reduction-strategy-expectation-ratio", boost::program_options::value<double>()->default_value(0.3), "The ratio used to decide if a clause can be kept or not.")
("max#sat-max-cache-size-first-page", boost::program_options::value<unsigned long>()->default_value((1UL<<32)), "The block size of memory allocated for the first page of the cache structure.")
("max#sat-max-cache-size-additional-page", boost::program_options::value<unsigned long>()->default_value((1UL<<29)), "The block size of memory allocated for the next page of the cache structure.")
("max#sat-max-cache-store-strategy", boost::program_options::value<std::string>()->default_value("not-touched"), "The strategy used to store the clause in a bucket (all, not-binary and not-touched).")
("max#sat-max-cache-clause-representation", boost::program_options::value<std::string>()->default_value("clause"), "The way the clause are represented in the cache (combi, sym, clause and index).")
("max#sat-max-cache-clause-representation-combi-limitVar-sym", boost::program_options::value<unsigned>()->default_value(20), "In the mixed strategy, if we have less than a given number of variable then we use the symmetry caching representation.")
("max#sat-max-cache-clause-representation-combi-limitVar-index", boost::program_options::value<unsigned>()->default_value(2000), "In the mixed strategy, if we have more than a given number of variable then we use the index caching representation.")
("max#sat-max-cache-limit-number-variable", boost::program_options::value<unsigned>()->default_value(100000), "The number of variables threshold used to decide if the cache is used or not.")
("max#sat-max-cache-limit-ratio", boost::program_options::value<double>()->default_value(0), "For the dynamic limit, posHit/negHit < ratio.")
("max#sat-max-cache-activated", boost::program_options::value<bool>()->default_value(true), "Activate or not the cache.")
("max#sat-max-cache-method", boost::program_options::value<std::string>()->default_value("list"), "The way the collision are handled (no-collision or list).")
("max#sat-max-scoring-method,sm",boost::program_options::value<std::string>()->default_value("vsads"),"The scoring method used for selecting the next variable. [mom, dlcs, vsids, vsads, jwts]")
("max#sat-max-scoring-method-freq-decay",boost::program_options::value<unsigned>()->default_value(128),"Gives the decay frequency")
("max#sat-max-phase-heuristic,ph",boost::program_options::value<std::string>()->default_value("polarity"),"The way the phase of the next decision is selected (false, true, polarity or occurrence).")
("max#sat-max-phase-heuristic-reversed,pha", boost::program_options::value<bool>()->default_value(false), "Consider or not the reverse of the current phase.")
("max#sat-ind-cache-reduction-strategy", boost::program_options::value<std::string>()->default_value("none"), "The strategy used to reduce the cache structure [none, expectation, cache or sharpSAT].")
("max#sat-ind-cache-reduction-strategy-cachet-limit", boost::program_options::value<unsigned long>()->default_value(10UL * (1<<21)), "The limit in term of number of entries, the cachet reduction strategy allows.")
("max#sat-ind-cache-reduction-strategy-expectation-limit", boost::program_options::value<unsigned long>()->default_value(100000), "The frequency in term of number of negative hits used for the expectation reduction strategy allows.")
("max#sat-ind-cache-reduction-strategy-expectation-ratio", boost::program_options::value<double>()->default_value(0.3), "The ratio used to decide if a clause can be kept or not.")
("max#sat-ind-cache-size-first-page", boost::program_options::value<unsigned long>()->default_value((1UL<<32)), "The block size of memory allocated for the first page of the cache structure.")
("max#sat-ind-cache-size-additional-page", boost::program_options::value<unsigned long>()->default_value((1UL<<29)), "The block size of memory allocated for the next page of the cache structure.")
("max#sat-ind-cache-store-strategy", boost::program_options::value<std::string>()->default_value("not-touched"), "The strategy used to store the clause in a bucket (all, not-binary and not-touched).")
("max#sat-ind-cache-clause-representation", boost::program_options::value<std::string>()->default_value("clause"), "The way the clause are represented in the cache (combi, sym, clause and index).")
("max#sat-ind-cache-clause-representation-combi-limitVar-sym", boost::program_options::value<unsigned>()->default_value(20), "In the mixed strategy, if we have less than a given number of variable then we use the symmetry caching representation.")
("max#sat-ind-cache-clause-representation-combi-limitVar-index", boost::program_options::value<unsigned>()->default_value(2000), "In the mixed strategy, if we have more than a given number of variable then we use the index caching representation.")
("max#sat-ind-cache-limit-number-variable", boost::program_options::value<unsigned>()->default_value(100000), "The number of variables threshold used to decide if the cache is used or not.")
("max#sat-ind-cache-limit-ratio", boost::program_options::value<double>()->default_value(0), "For the dynamic limit, posHit/negHit < ratio.")
("max#sat-ind-cache-activated", boost::program_options::value<bool>()->default_value(true), "Activate or not the cache.")
("max#sat-ind-cache-method", boost::program_options::value<std::string>()->default_value("list"), "The way the collision are handled (no-collision or list).")
("max#sat-ind-scoring-method,sm",boost::program_options::value<std::string>()->default_value("vsads"),"The scoring method used for selecting the next variable. [mom, dlcs, vsids, vsads, jwts]")
("max#sat-ind-scoring-method-freq-decay",boost::program_options::value<unsigned>()->default_value(128),"Gives the decay frequency")
("max#sat-ind-phase-heuristic,ph",boost::program_options::value<std::string>()->default_value("polarity"),"The way the phase of the next decision is selected (false, true, polarity or occurrence).")
("max#sat-ind-phase-heuristic-reversed,pha", boost::program_options::value<bool>()->default_value(false), "Consider or not the reverse of the current phase.")
("max#sat-component-on-ind",boost::program_options::value<bool>()->default_value(true),"Compute the connected component focusing or not the set of ind variables.")
("min#sat-greedy-init",boost::program_options::value<bool>()->default_value(false),"Search for a first interpretation greedily.")
("min#sat-and-dig",boost::program_options::value<bool>()->default_value(true),"When a decomposable AND node occurs we search for an instantiation to be able to get a bound.")
("min#sat-threshold",boost::program_options::value<double>()->default_value(1.0),"Search if we can find an assignment such that the number of weighted models is greater than a given threshold.")
("min#sat-min-cut-upperBound",boost::program_options::value<bool>()->default_value(true),"Activate the cutting process on the min variables regarding an upper bound.")
("min#sat-min-heuristic-phase",boost::program_options::value<std::string>()->default_value("best"),"Try to look if the best solution found so far is a good phase heuristic (best) or if it worth to consider the literal with th higher weight.")
("min#sat-min-heuristic-phase-random",boost::program_options::value<unsigned>()->default_value(5),"That is the percentage of random choice for the phase selection on the min variables.")
("min#sat-min-cache-reduction-strategy", boost::program_options::value<std::string>()->default_value("none"), "The strategy used to reduce the cache structure [none, expectation, cache or sharpSAT].")
("min#sat-min-cache-reduction-strategy-cachet-limit", boost::program_options::value<unsigned long>()->default_value(10UL * (1<<21)), "The limit in term of number of entries, the cachet reduction strategy allows.")
("min#sat-min-cache-reduction-strategy-expectation-limit", boost::program_options::value<unsigned long>()->default_value(100000), "The frequency in term of number of negative hits used for the expectation reduction strategy allows.")
("min#sat-min-cache-reduction-strategy-expectation-ratio", boost::program_options::value<double>()->default_value(0.3), "The ratio used to decide if a clause can be kept or not.")
("min#sat-min-cache-size-first-page", boost::program_options::value<unsigned long>()->default_value((1UL<<32)), "The block size of memory allocated for the first page of the cache structure.")
("min#sat-min-cache-size-additional-page", boost::program_options::value<unsigned long>()->default_value((1UL<<29)), "The block size of memory allocated for the next page of the cache structure.")
("min#sat-min-cache-store-strategy", boost::program_options::value<std::string>()->default_value("not-touched"), "The strategy used to store the clause in a bucket (all, not-binary and not-touched).")
("min#sat-min-cache-clause-representation", boost::program_options::value<std::string>()->default_value("clause"), "The way the clause are represented in the cache (combi, sym, clause and index).")
("min#sat-min-cache-clause-representation-combi-limitVar-sym", boost::program_options::value<unsigned>()->default_value(20), "In the mixed strategy, if we have less than a given number of variable then we use the symmetry caching representation.")
("min#sat-min-cache-clause-representation-combi-limitVar-index", boost::program_options::value<unsigned>()->default_value(2000), "In the mixed strategy, if we have more than a given number of variable then we use the index caching representation.")
("min#sat-min-cache-limit-number-variable", boost::program_options::value<unsigned>()->default_value(100000), "The number of variables threshold used to decide if the cache is used or not.")
("min#sat-min-cache-limit-ratio", boost::program_options::value<double>()->default_value(0), "For the dynamic limit, posHit/negHit < ratio.")
("min#sat-min-cache-activated", boost::program_options::value<bool>()->default_value(true), "Activate or not the cache.")
("min#sat-min-cache-method", boost::program_options::value<std::string>()->default_value("list"), "The way the collision are handled (no-collision or list).")
("min#sat-min-scoring-method,sm",boost::program_options::value<std::string>()->default_value("vsads"),"The scoring method used for selecting the next variable. [mom, dlcs, vsids, vsads, jwts]")
("min#sat-min-scoring-method-freq-decay",boost::program_options::value<unsigned>()->default_value(128),"Gives the decay frequency")
("min#sat-min-phase-heuristic,ph",boost::program_options::value<std::string>()->default_value("polarity"),"The way the phase of the next decision is selected (false, true, polarity or occurrence).")
("min#sat-min-phase-heuristic-reversed,pha", boost::program_options::value<bool>()->default_value(false), "Consider or not the reverse of the current phase.")
("min#sat-ind-cache-reduction-strategy", boost::program_options::value<std::string>()->default_value("none"), "The strategy used to reduce the cache structure [none, expectation, cache or sharpSAT].")
("min#sat-ind-cache-reduction-strategy-cachet-limit", boost::program_options::value<unsigned long>()->default_value(10UL * (1<<21)), "The limit in term of number of entries, the cachet reduction strategy allows.")
("min#sat-ind-cache-reduction-strategy-expectation-limit", boost::program_options::value<unsigned long>()->default_value(100000), "The frequency in term of number of negative hits used for the expectation reduction strategy allows.")
("min#sat-ind-cache-reduction-strategy-expectation-ratio", boost::program_options::value<double>()->default_value(0.3), "The ratio used to decide if a clause can be kept or not.")
("min#sat-ind-cache-size-first-page", boost::program_options::value<unsigned long>()->default_value((1UL<<32)), "The block size of memory allocated for the first page of the cache structure.")
("min#sat-ind-cache-size-additional-page", boost::program_options::value<unsigned long>()->default_value((1UL<<29)), "The block size of memory allocated for the next page of the cache structure.")
("min#sat-ind-cache-store-strategy", boost::program_options::value<std::string>()->default_value("not-touched"), "The strategy used to store the clause in a bucket (all, not-binary and not-touched).")
("min#sat-ind-cache-clause-representation", boost::program_options::value<std::string>()->default_value("clause"), "The way the clause are represented in the cache (combi, sym, clause and index).")
("min#sat-ind-cache-clause-representation-combi-limitVar-sym", boost::program_options::value<unsigned>()->default_value(20), "In the mixed strategy, if we have less than a given number of variable then we use the symmetry caching representation.")
("min#sat-ind-cache-clause-representation-combi-limitVar-index", boost::program_options::value<unsigned>()->default_value(2000), "In the mixed strategy, if we have more than a given number of variable then we use the index caching representation.")
("min#sat-ind-cache-limit-number-variable", boost::program_options::value<unsigned>()->default_value(100000), "The number of variables threshold used to decide if the cache is used or not.")
("min#sat-ind-cache-limit-ratio", boost::program_options::value<double>()->default_value(0), "For the dynamic limit, posHit/negHit < ratio.")
("min#sat-ind-cache-activated", boost::program_options::value<bool>()->default_value(true), "Activate or not the cache.")
("min#sat-ind-cache-method", boost::program_options::value<std::string>()->default_value("list"), "The way the collision are handled (no-collision or list).")
("min#sat-ind-scoring-method,sm",boost::program_options::value<std::string>()->default_value("vsads"),"The scoring method used for selecting the next variable. [mom, dlcs, vsids, vsads, jwts]")
("min#sat-ind-scoring-method-freq-decay",boost::program_options::value<unsigned>()->default_value(128),"Gives the decay frequency")
("min#sat-ind-phase-heuristic,ph",boost::program_options::value<std::string>()->default_value("polarity"),"The way the phase of the next decision is selected (false, true, polarity or occurrence).")
("min#sat-ind-phase-heuristic-reversed,pha", boost::program_options::value<bool>()->default_value(false), "Consider or not the reverse of the current phase.")
("min#sat-component-on-ind",boost::program_options::value<bool>()->default_value(true),"Compute the connected component focusing or not the set of ind variables.")



